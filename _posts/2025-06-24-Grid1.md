---
layout: post
title: "그리드 시스템 구현 (1) - 그리드 생성"
date: 2025-06-24
categories: [Grid]
image: /assets/images/DrawGrid.png
excerpt: "우선 모든 시스템의 근간인 그리드를 생성한다. 그리드를 생성하는 데 필요한 것은 격자 모양의 무늬 메쉬와 그 안에 들어갈 정사각형 모양의 메쉬이다.
 둘 모두 ProceduralMesh를 활용해 구현하였다."
---
 우선 모든 시스템의 근간인 그리드를 생성한다. 
그리드를 생성하는 데 필요한 것은 격자 모양의 무늬 메쉬와 그 안에 들어갈 정사각형 모양의 메쉬이다. 둘 모두 ProceduralMesh를 활용해 구현하였다.

<div class="code-toggle">
  <button class="toggle-btn" onclick="this.nextElementSibling.classList.toggle('collapsed')">
    ▶ 코드 보기
  </button>
  <div class="code-block collapsed">
{% raw %}
<pre><code class="language-cpp">UPROPERTY()
	class UProceduralMeshComponent* ProceduralMesh_Squares;
	UPROPERTY()
	class UProceduralMeshComponent* ProceduralMesh_Lines;

    void DrawLine(FVector StartVector, FVector EndVector, float Thiccness, TArray&lt;FVector&gt;& Vertices, TArray&lt;int32&gt;& Triangles);

	void DrawSquare(FVector StartVector, float Size, TArray&lt;FVector&gt;& Vertices, TArray&lt;int32&gt;& Triangles, TArray&lt;FLinearColor&gt;& VerterColors);

	float TileSize;
	int32 Rows;
	int32 Columns;
	float LineThiccness;
	float LineOpacity;
	float SquareOpacity;

    TArray&lt;FVector&gt; LineVertices;
	TArray&lt;int32&gt; LineTriangles;
	TArray&lt;FVector&gt; SquareVertices;
	TArray&lt;int32&gt; SquareTriangles;
	TArray&lt;FLinearColor&gt; SquareVertexColors;
	TArray&lt;FVector&gt; SquareNormals;
	TArray&lt;FVector2D&gt; SquareUV0;
</code></pre>
{% endraw %}
  </div>
</div>

다음과 같이 선언 후



<div class="code-toggle">
  <button class="toggle-btn" onclick="this.nextElementSibling.classList.toggle('collapsed')">
    ▶ 코드 보기
  </button>
  <div class="code-block collapsed">
{% raw %}
<pre><code class="language-cpp">void AGridActor::DrawLine(FVector StartVector, FVector EndVector, float Thiccness, TArray&lt;FVector&gt;& Vertices, TArray&lt;int32&gt;& Triangles)
{
	float HalfThiccness = Thiccness / 2;

	FVector Direction = FVector::CrossProduct((EndVector - StartVector).GetSafeNormal(0.00001f), FVector(0.0f, 0.0f, 1.0f));

	TArray&lt;FVector&gt; SetCorner;
	TArray&lt;int32&gt; SetTriangles;

	SetTriangles.Add(Vertices.Num() + 2);
	SetTriangles.Add(Vertices.Num() + 1);
	SetTriangles.Add(Vertices.Num() + 0);
	SetTriangles.Add(Vertices.Num() + 2);
	SetTriangles.Add(Vertices.Num() + 3);
	SetTriangles.Add(Vertices.Num() + 1);

	Triangles.Append(SetTriangles);

	SetCorner.Add(StartVector + (Direction * HalfThiccness));
	SetCorner.Add(EndVector + (Direction * HalfThiccness));
	SetCorner.Add(StartVector - (Direction * HalfThiccness));
	SetCorner.Add(EndVector - (Direction * HalfThiccness));

	Vertices.Append(SetCorner);
}
</code></pre>
{% endraw %}
  </div>
</div>
  
  
  
<div class="code-toggle">
  <button class="toggle-btn" onclick="this.nextElementSibling.classList.toggle('collapsed')">
    ▶ 코드 보기
  </button>
  <div class="code-block collapsed">
{% raw %}
<pre><code class="language-cpp">void AGridActor::DrawSquare(FVector StartVector, float Size, TArray&lt;FVector&gt;& Vertices, TArray&lt;int32&gt;& Triangles, TArray&lt;FLinearColor&gt;& VertexColors)
{
    FVector TopLeft = StartVector + FVector(0.0f, Size, 0.0f);
    FVector TopRight = StartVector + FVector(Size, Size, 0.0f);
    FVector BottomLeft = StartVector;
    FVector BottomRight = StartVector + FVector(Size, 0.0f, 0.0f);

    int32 StartIndex = Vertices.Num();

    TArray&lt;FVector&gt; SetVertices;
    TArray&lt;int32&gt; SetTriangles;
    TArray&lt;FLinearColor&gt; SetVertexColors;

    SetVertices.Add(BottomLeft);
    SetVertices.Add(BottomRight);
    SetVertices.Add(TopRight);
    SetVertices.Add(TopLeft);

    Vertices.Append(SetVertices);

    SetTriangles.Add(StartIndex + 0);
    SetTriangles.Add(StartIndex + 3);
    SetTriangles.Add(StartIndex + 2);

    SetTriangles.Add(StartIndex + 0);
    SetTriangles.Add(StartIndex + 2);
    SetTriangles.Add(StartIndex + 1);

    Triangles.Append(SetTriangles);

    SetVertexColors.Add(FLinearColor(0.0f, 0.0f, 0.0f, SquareOpacity_Transparent));
    SetVertexColors.Add(FLinearColor(0.0f, 0.0f, 0.0f, SquareOpacity_Transparent));
    SetVertexColors.Add(FLinearColor(0.0f, 0.0f, 0.0f, SquareOpacity_Transparent));
    SetVertexColors.Add(FLinearColor(0.0f, 0.0f, 0.0f, SquareOpacity_Transparent));

    VertexColors.Append(SetVertexColors);

    SquareNormals.Add(FVector(0.0f, 0.0f, 1.0f));
    SquareNormals.Add(FVector(0.0f, 0.0f, 1.0f));
    SquareNormals.Add(FVector(0.0f, 0.0f, 1.0f));
    SquareNormals.Add(FVector(0.0f, 0.0f, 1.0f));
}
</code></pre>
{% endraw %}
  </div>
</div>
  
  
    
 함수를 다음과 같이 구현해 ProceduralMesh에 들어갈 버텍스를 추가시켜준다. 고정된 색을 가진 것으로 구현될 격자무늬와 달리 내부 타일은 색이 바뀌도록 구현하기 위해 별도의 인수를 추가하였다.
인수를 이용해 색을 변경하는 법은 다음 게시글에 업로드 할 예정이다.
  
  
  
<div class="code-toggle">
  <button class="toggle-btn" onclick="this.nextElementSibling.classList.toggle('collapsed')">
    ▶ 코드 보기
  </button>
  <div class="code-block collapsed">
{% raw %}
<pre><code class="language-cpp">float LineStart;
	float LineEnd;

	for (int32 i = 0; i &lt;= Rows; i++)
	{
		LineStart = TileSize * i;
		LineEnd = LineWidth();
		DrawLine(FVector(LineStart, 0.0f, 5.0f), FVector(LineStart, LineEnd, 5.0f), LineThiccness, LineVertices, LineTriangles);
	}

	for (int32 i = 0; i &lt;= Columns; i++)
	{
		LineStart = TileSize * i;
		LineEnd = LineHeight();
		DrawLine(FVector(0.0f, LineStart, 5.0f), FVector(LineEnd, LineStart, 5.0f), LineThiccness, LineVertices, LineTriangles);
	}

    for (int32 i = 0; i &lt; Rows; i++)
	{
	for (int32 j = 0; j &lt; Columns; j++)
		DrawSquare(FVector(i * TileSize, j * TileSize, 10.0f), TileSize, SquareVertices, SquareTriangles, SquareVertexColors);
	}
</code></pre>
{% endraw %}
  </div>
</div>
  
 그 후 구현한 함수를 활용해 ProceduralMesh의 형태를 잡은 후 
  
```cpp
	ProceduralMesh_Lines->CreateMeshSection(0, LineVertices, LineTriangles, {}, {}, {}, {}, true);
	ProceduralMesh_Squares->CreateMeshSection_LinearColor(0, SquareVertices, SquareTriangles, SquareNormals, SquareUV0, SquareVertexColors, {}, true);
```
 CreateMeshSection 을 활용해 메쉬를 그린다.


<img src="{{ '/assets/images/DrawGrid2.png' | relative_url }}" alt="결과" style="width: 70%; margin: 20px auto; display: block; border-radius: 8px;">

잘 적용되는 것을 확인할 수 있다.